# Provider ReflectionService

Этот провайдер использует [\ReflectionClass](http://php.net/manual/ru/class.reflectionclass.php)
, с помощью регулярного выражения ищет нужную аннотацию(по умолчанию она **service**, может быть изменена в 
конструкторе) в DocComment класса, аннотация может быть указана как пустая строка '' это будет значит загружать все 
объекты, не стоит забывать о [приоритете провайдеров](../providerPrioritet.md).

Если объект необходимо загрузить он начинает анализировать конструктор загружаемого объекта на поиск зависимостей, в 
следущем приоритете:

1. Если указана специальная аннотация для конструктора (по умолчанию она inject, но может быть изменена в конструкторе 
провайдера).
2. Если указан тип аргумента.
3. Если нет ни типа, ни аннотаци используется имя аргумента.

Service значит что объект будет создан в единственном экземпляре это очень удобно для объектов stateless.

Рассмотрим пример конструктора:

```php
class Magic
{
    /**
     * @inject SomeContainer $e
     */
    public function __construct(\stdClass $e, \stdClass $magic){}
}
```

Ну и теперь пример как это использовать.

```php
$service = new ReflectionService('');   // Загружать все классы, даже без анотаций
$providers[] = $service;
$container = new Container($providers);
```

1. Специальная аннотация указана и для $e указывает на SomeContainer, для $magic аннотации нет
2. Тип аргумента указан это \stdClass для $e и $magic.
3. Имя аргумента это e и magic.

Значит в **$e** будет **SomeContainer**, а в **$magic** будет **\stdClass**. 

[Примеры использования смотреть в юните тестах](../../test/Unit/Provider/ReflectionServiceTest.php)