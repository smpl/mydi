# Базовое знакомство с LocatorInterface

Это самый главный класс, в котором хранятся все ваши определения и 
зависимости, он напоминает обычное **KeyValue** хранилище.
 
**key** - обычная строка, которая обозначаем уникальное имя.

**value** - хранит значение, int, string, bool, object, function, 
resource, объекты реализующие интерфейс **\Smpl\Mydi\ContainerInterface** 
[которые обрабатываются по особенному](../Container) об их использование 
отдельно, любое из доступных значений value мы будем называть 
**Container**(контейнер или зависимость).

Также внутри **LocatorInterface** имеются объекты реализующие 
**\Smpl\Mydi\LoaderInterface** (или Loader, загрузчик) которые используются 
для отложенной загрузки, [об их использование рассказано отдельно](../Loader).

## Аргументы конструктора

### loaders
Список (массив) загрузчиков, для отложенной загрузки контейнеров, не 
обязательный параметр

## Как работает LocatorInterface

Для работы с **LoaderInterface** можно использовать **\ArrayAccess** 
(работать как с обычным массивом) или ООП методы (get, has и тд).

### Как работает установка зависимостей

Вы передаете уникальное имя и значение контейнера, которое сохраняется в 
KeyValue хранилище.

### Как работает получение зависимостей

Получения зависимостей процесс довольно сложный и не тривиальный, условно 
могут возникать следующие ситуации:

#### Простая загрузка

Внутри **locator** данные храняться в KeyValue хранилище(массив), по 
ключу находиться запись и возвращается value в случае если value не 
реализует интерфейс **ContainerInterface**.

#### Простая загрузка объекта с интерфейсом ContainerInterface

Также как в *простой загрузке*, только value является объектом с интерфейсом 
**ContainerInterface**, у данного объекта вызывается метод resolve в 
качестве аргумента, туда передается текущий locator, [подробней](../Container)

#### Отложенная загрузка.

Загрузка осуществляется в случае если **простая загрузка** не может найти 
контейнер по ключу, идет поиск **LoaderInterface** который может 
загрузить данный контейнер, потом вызывается метод для загрузки **load** 
результат котрого *устанавливается* в KeyValue хранилище и уже далее 
идет **простая загрузка** [подробней](..Loader)

### Получение зависимостей в общем виде

Это показано для примера, напишу в виде псевдо кода русским языком.

```
Если объект не может быть загружен через KeyValue
    Если не найден Loader
        Исключение неизвестное имя контейнера
    Поместим в KeyValue хранилише то что вернет Loader
$result равен value из KeyValue хранилища
Если результат реализует интерфейс ContainerInterface
    $result = $result->resolve($this)
Возвращаем $result
```

Также в алгоритме есть защита от зацикливаний, когда **А** зависит от **Б** 
а **Б** зависит от **А** и такое может зациклиться до бесконечности.

### Получения дерева зависимостей

Имеется возможно получить карту всех зависимостей и посмотреть кто что 
использует в своей работе, ответ выдается в виде обычного массива.

Ключ массива - имя контейнера.

Значение массива - Массив имен контейнеров испольщуемых для получения 
контейнера.

например:

```php
$result = [
    'a' => ['b', 'c'],
    'b' => [],
    'c' => ['d'],
    'd' => []
];
```
Этот результат значит что **a** зависит от **b** и **c**, **b** не 
зависит ни от кого, **c** зависит от **d**, **d** не зависит ни от кого.

С помощью любового инструмента, можно визуализировать зависимости.

## Практика использования

В качестве примера я буду писать юнит тесты с утверждениями что я ожидаю 
и как это получить, это гарантирует что документацию будет всегда актуальна.

К сожалению внутри юнит тестов чтобы использовать сторонние библиотеки 
их необходимо добавить в зависимость в проекта, что будет мягко говоря странно, 
так использоваться они будут только в юнит тесте поэтому вместо 
конкретных классов я буду использовать **\stdClass** который будет 
хранить в себе параметры.

В качестве текущего примера я просто покажу как использовать библиотеку. 
Детали использования отложенной загрузки и ContainerInterface будет 
рассмотренно позже.